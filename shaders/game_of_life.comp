#version 460

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D uSrc;
layout(binding = 1, rgba8) uniform writeonly image2D uDst;

layout(push_constant) uniform Push
{
    uvec2 size;
    uint wrap;
    uint _pad;
} pc;

int wrap_i(int v, int m)
{
    int r = v % m;
    return (r < 0) ? (r + m) : r;
}

ivec2 neighbor_coord(ivec2 p)
{
    if (pc.wrap != 0u)
    {
        return ivec2(wrap_i(p.x, int(pc.size.x)), wrap_i(p.y, int(pc.size.y)));
    }
    return clamp(p, ivec2(0), ivec2(int(pc.size.x) - 1, int(pc.size.y) - 1));
}

int alive_at(ivec2 p)
{
    vec4 c = texelFetch(uSrc, p, 0);
    return (c.r > 0.5) ? 1 : 0;
}

void main()
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (pos.x >= int(pc.size.x) || pos.y >= int(pc.size.y))
    {
        return;
    }

    int n = 0;
    for (int dy = -1; dy <= 1; ++dy)
    {
        for (int dx = -1; dx <= 1; ++dx)
        {
            if (dx == 0 && dy == 0) continue;
            ivec2 p = neighbor_coord(pos + ivec2(dx, dy));
            n += alive_at(p);
        }
    }

    int cur = alive_at(pos);
    bool nextAlive = (cur != 0) ? (n == 2 || n == 3) : (n == 3);

    vec4 outColor = nextAlive ? vec4(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 1.0);
    imageStore(uDst, pos, outColor);
}

